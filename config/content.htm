<h1>member</h1>
<p><br/><a href="https://s40523253.github.io/cd2020">40523253</a><br/><a href="https://40623117.github.io/cd2020">40623117</a><br/><a href="https://40623252.github.io/cd2020">40623252</a><br/><a href="https://s40723221.github.io/cd2020">40723221</a><span><span> </span>(group leader)</span><br/><a href="https://s40723222.github.io/cd2020">40723222</a><br/><a href="https://s40723228.github.io/cd2020">40723228</a><br/><a href="https://s40723236.github.io/cd2020">40723236</a><br/><a href="https://s40723237.github.io/cd2020">40723237</a><br/><a href="https://s40723240.github.io/cd2020">40723240</a><br/><a href="https://s40723243.github.io/cd2020">40723243</a><br/><a href="https://s40723244.github.io/cd2020">40723244</a><br/><a href="https://s40723249.github.io/cd2020">40723249</a><br/><a href="https://40732331.github.io/cd2020">40732331</a></p>
<h1>week</h1>
<h2>week1-5</h2>
<h4><strong><span>week1</span></strong></h4>
<hr/>
<p>1.登入自己的github帳戶，並且創建名為cd2020的個人倉儲。</p>
<p>2.進入存放的資料夾例如;tmp</p>
<p>3.在小黑窗上打上git clone https://github.com/s40723221/cd2020。</p>
<p>4.git submodule add https://github.com/mdecourse/cmsimde.git。</p>
<p>5.完成後使用cd cd2020 -&gt;cd cmsimde進入cmsimde的資料夾內。</p>
<p>6.完成之後使用python wsgi.py進入靜態9443內編輯個人網站的資料。</p>
<p>7.使用git add .  -&gt; commit -m ＂標題＂ -&gt; git push將剛剛編輯好的東西上傳。</p>
<p>8.進入個人倉儲的setting中更改branch(分支)至master。</p>
<p><strong><span>影片教學:</span></strong></p>
<p><span><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/V7Njg-o9bm4" width="560"></iframe></span></p>
<hr/>
<h4><strong><span>week2</span></strong></h4>
<p><strong><span>將可攜系統下的python 3.7.3系統更新至python 3.8.2</span></strong></p>
<p><span>1.進入<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></span></p>
<p><span>2.往下滑到最底，下載<a href="https://www.python.org/ftp/python/3.8.2/python-3.8.2-amd64.exe">Windows x86-64 executable installer</a>(上下兩者分別為<a href="https://www.python.org/ftp/python/3.7.7/python-3.7.7-embed-amd64.zip">Windows x86-64 embeddable zip file</a>和<a href="https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64-webinstall.exe">Windows x86-64 web-based installer</a>這兩者是嵌入式64位元python的可執行壓縮檔案和64位元網際端的可執行檔案)在本次可熙的更新中不會使用到</span></p>
<p><span><img alt="" height="104" src="https://s40723221.github.io/cd2020/images/python%20%E5%9F%B7%E8%A1%8C%E6%AA%94.PNG" width="409"/></span></p>
<p><span>3.接著開始下載切記不要勾選pip選項，接著按下next</span></p>
<p><span>4.先將下載下來的python3.8.2放置桌面，並且將y槽下的data新增加一個py382的資料夾方便之後可以做測試是否3.8.2之python可以正常的運行</span></p>
<p><span>5.將剛剛下載之python3.8.2放置於剛剛創建的py382中切記不要將原先的py373刪除，若之後py382的執行產生錯誤才可以使用py373做返回原版本的動作</span></p>
<p><span>6.更改執行檔start_mdecourse.bat</span></p>
<p><strong><span>將底下py373處更改為自己下在python3.8.2所儲存的資料夾名稱</span></strong></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
subst %Disk%: "data"

%Disk%:

set HomePath=%Disk%:\home_mdecourse
set HomeDrive=%Disk%:\home_mdecourse
set Home=%Disk%:\home_mdecourse
set USERPROFILE=%Disk%:\home_mdecourse

REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"

set PYTHONPATH=%Disk%:\py373\DLLs;%Disk%:\py373\Lib;%Disk%:\py373\Lib\site-packages;
set PYTHONHOME=%Disk%:\py373

set GIT_HOME=%Disk%:\portablegit\bin\
set GIT_SSH=%Disk%:\putty\plink.exe

set path_python=%Disk%:\py373;%Disk%:\py373\Scripts;
set path_msys2=%Disk%:\msys64\mingw64\bin;
REM coreutils is for compiling fossil scm
set path_coreutils=%Disk%:\coreutils-5.3.0\bin;%Disk%:\depends22_x64;
set path_tcc=%Disk%:\tcc;
set path_cmake=%Disk%:\cmake-3.10.1-win64-x64\bin;
set path_nodejs=Disk%:\nodejs;%Disk%:\nodejs\appdata\roaming\npm;
set path_git=%Disk%:\portablegit\bin;
set path_xming=%Disk%:\Xming;
set path_latex=%%Disk%:\Pandoc;%Disk%:\TinyTeX\bin\win32;

path=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;

start /MIN %Disk%:\wscite415\wscite\SciTE.exe
start /MIN %Disk%:\wscite415\wscite\SciTE.exe

start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe


Exit</pre>
<p><span></span>7.重新啟動剛剛更新的執行檔</p>
<p>8.執行<strong><span>python get-pip.py</span></strong></p>
<p>9..執行<strong><span>python -m pip install flask flask-cors markdown lxml bs4 pelican leo</span></strong></p>
<p><span><strong>影片教學:</strong></span></p>
<p><span><strong><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/ft4s-DvMk_M" width="560"></iframe></strong></span></p>
<hr/>
<p><span><strong>git pull request操作說明:</strong></span></p>
<p><span>1.以自己github之帳號fork老師的倉儲也就是<span>fork</span>:<a href="https://github.com/mdecourse/cd2020">https://github.com/mdecourse/cd2020</a></span></p>
<p><span>2.接下來到自己的倉儲中找到剛剛fork下來的老師倉儲並且複製網址</span></p>
<p><span>3.利用git clone 自己帳號下老師的網址</span></p>
<p><span>4.在執行git submodule add<span> </span><a href="https://github.com/mdecourse/cmsimde.git">https://github.com/mdecourse/cmsimde.git</a></span></p>
<p><span>5.進入到9443開始編輯自己帳號下老師的網站</span></p>
<p><span>6.編輯完成後執行git add commit push三個步驟</span></p>
<p><span>7.利用自己帳號下修改完成的老師倉儲建立新的pull request</span></p>
<p><span><img alt="" height="84" src="https://s40723221.github.io/cd2020/images/new%20pull%20request.PNG" width="207"/></span></p>
<p><span><img alt="" height="97" src="https://s40723221.github.io/cd2020/images/add%20commit%20pull%20request.PNG" width="1018"/></span></p>
<p><span>8.按下提交之後等待老師接受並且merge即可完成此次的pull request</span></p>
<p><span><strong><span color="#000000">w2直播進程:</span></strong></span></p>
<p><span><strong><span color="#000000">分工內容:</span></strong></span></p>
<p><span><span color="#000000">40523253:亂數分組程式<br/>40623117:亂數分組程式<br/>40623252:4輪車<br/>40723221 (group leader) :4輪車<br/>40723222:4輪車<br/>40723228:亂數分組程式<br/>40723236:4輪車<br/>40723237:可攜系統<br/>40723240:4輪車<br/>40723243:4輪車<br/>40723244:可攜系統<br/>40723249:可攜系統<br/>40732331:4輪車 </span></span></p>
<p><span><strong><span color="#000000">注意事項:</span></strong></span></p>
<p><span><span color="#000000">1.視課堂進度上傳影片<br/>2.不管會不會做每周都要push<br/>3.可以從gitter上面提問<br/>4.直播大家輪流主持，直播前半部分有教大家如何開直播了<br/>5.git pull request每個人都要會之後要更改東西比較方便<br/>6.不會做的可以去看我的網站我會盡可能提早更新，再不行就到gitter上面提問可以在這邊提問 gitter:https://gitter.im/mdecourse/cd2020<br/>7.2020年3月26日到期assignment 1的pdf繳交請在時間內上傳到自己倉儲的download上<br/>8.pdf上寫上進度，之後打分數依照pdf打分</span></span></p>
<p><span><strong><span color="#000000">直播進程影片:</span></strong></span></p>
<p><strong><span><span color="#000000"><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/HXS95dlMSv8" width="560"></iframe></span></span></strong></p>
<h4><strong><span>week3</span></strong></h4>
<p><span style="color: #ff0000;">40723221邱正宇的本周報告:</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/uDAZ07xBHMs" width="560"></iframe></p>
<p><span style="color: #ff0000;">40723249顏士勛的本周報告:</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/lGkbJC9OZ70" width="560"></iframe></p>
<h2>week6-10</h2>
<p>40523253</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/o88lNqgScX4" width="560"></iframe></p><h2>week11-15</h2>
<h2>week16-18</h2>
<h1>refer ebook</h1>
<h2>External controller</h2>
<p><span style="color: #0000ff;">本資料由40723240提供</span></p>
<p><strong><span style="color: #ff0000;">External controller tutorial </span></strong><br/><strong><span style="color: #ff0000;"> 外部控制器教程 </span></strong></p>
<p><span style="color: #ff0000;">There are several ways one can control a robot or simulation in CoppeliaSim:</span> <br/>在 CoppeliaSim 中，有幾種方法可以控制機器人或使其模擬更加仿真： <br/> <br/><span style="color: #ff0000;">The most convenient way is to write a child script that will handle the behaviour of a given robot or model. It is the most convenient way, because child scripts are directly attached to scene objects, they will be duplicated together with their associated scene objects, they do not need any compilation with an external tool, they can run in threaded or non-threaded mode, they can be extended via custom Lua function or via a Lua extension library. Another major advantage in using child scripts: there is no communication lag as with the last 3 methods mentioned in this section (i.e. the regular API is used), and child scripts are part of the application main thread (inherent synchronous operation). There are several drawback to writing scripts however: you don't have the choice of the programming language, you can't have the fastest code, and you can't directly access external function libraries, except the Lua extension libraries.</span></p>
<p><br/>最方便的方法是編寫一段指令來處理給定機器人或模型的動作。這<br/>是最方便的方法，因為指令直接附加到物件上，它們將與相關的物<br/>件一起復制，它們不需要使用外部工具進行任何編譯，它們可以在<br/>線性或非線性模式下運行，它們可以通過自定義 Lua 函數或 Lua 擴<br/>展庫進行擴展。使用指令的另一個主要優點是：與本節中提到的後<br/>3 種方法（即使用常規 API）一樣，沒有通信延遲，並且指令是應用<br/>程序主線程的一部分（固有的同步操作）。但是，編寫指令有幾個缺<br/>點：您無法選擇編程語言，不能擁有最快的代碼，並且除了 Lua 擴<br/>展庫之外，您無法直接訪問外部函數庫。 <br/> <br/><span style="color: #ff0000;">Another way one can control a robot or a simulation is by writing a plugin. The plugin mechanism allows for callback mechanisms, custom Lua function registration, and of course access to external function libraries. A plugin is often used in conjunction with child scripts (e.g. the plugin registers custom Lua functions, that, when called from a child script, will call back a specific plugin function). A major advantage in using plugins is also that there is no communication lag as with the last 3 methods mentioned in this section (i.e. the regular API is used), and that a plugin is part of the application main thread (inherent synchronous operation). The drawbacks with plugins are: they are more complicated to program, and they need to be compiled with an external too. Refer also to the plugin tutorial.</span></p>
<p><br/>可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使<br/>用回調機制，自定義 Lua 函數註冊，當然還可以訪問外部函數庫。<br/>插件通常與指令結合使用（例如，插件註冊自定義的 Lua 函數，當<br/>從指令中調用時，該 Lua 函數將回調特定的插件函數）。使用插件的<br/>主要優勢還在於，與本節中提到的後 3 種方法（即使用常規 API）一<br/>樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的<br/>同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用<br/>外部編譯。另請參閱插件教程。 <br/> <br/><span style="color: #ff0000;">A third and forth way one can control a robot or a simulation is by </span><br/><span style="color: #ff0000;">writing an external client application that relies on the remote API. This is a very convenient and easy way, if you need to run the control code from an external application, from a robot or from another computer. This also allows you to control a simulation or a model (e.g. a virtual robot) with the exact same code as the one that runs the real robot. The remote API comes in two versions: the B0-based remote API, and the legacy remote API.</span></p>
<p><br/>控制機器人或模擬的第三種方法是編寫依賴於遠程 API 的外部客戶<br/>端應用程序。如果您需要從外部應用程序，機器人或另一台電腦運<br/>行控制代碼，這是一種非常便捷的方法。這也使您可以使用與運行<br/>真實機器人完全相同的代碼來控制仿真機器人或模型（例如虛擬機<br/>器人）。遠程 API 有兩個版本：基於 B0 的遠程 API 和舊版遠程 API。 <br/> <br/><span style="color: #ff0000;">A fifth way to control a robot or a simulation is via a ROS node. In a similar way as the remote API, ROS is a convenient way to have several distributed processes communicate with each other. While the remote API is very lightweight and fast, it allows only communication with CoppeliaSim. ROS on the other hand allows connecting virtually any number of processes with each other, and a large amount of compatible libraries are available. It is however heavier and more complicated than the remote API. Refer to the ROS interfaces for details.</span></p>
<p><br/>控制機器人或仿真的第五種方法是通過 ROS 節點。 ROS 與遠程 API<br/>相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程 API 非<br/>常輕巧且快速，但它僅允許與 CoppeliaSim 通信。另一方面，ROS 允<br/>許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。但<br/>是，它比遠程 API 多並且更複雜。有關詳細信息，請參閱 ROS 接<br/>口。</p>
<p><span style="color: #ff0000;">A sixth way to control a robot or a simulation is via a BlueZero (BØ) node. In a similar way as ROS, BlueZero is a convenient way to have several distributed processes communicate with each other, and is a lightweight and cross-platform solution. Refer to the BlueZero interface for details.</span></p>
<p><br/>控制機器人或模擬的第六種方法是通過 BlueZero（BØ）節點。與<br/>ROS 類似，BlueZero 是使多個分佈式進程相互通信的一種便捷方<br/>法，並且是一種輕量的跨平台解決方案。有關詳細信息，請參考<br/>BlueZero 界面。 <br/> <br/><span style="color: #ff0000;">A seventh way to control a robot or a simulation is by writing an external application that communicates via various means (e.g. pipes, sockets, serial port, etc.) with a CoppeliaSim plugin or CoppeliaSim script. Two major advantages are the choice of programming language, which can be just any language, and the flexibility. Here also, the control code can run on a robot, or a different computer. This way of controlling a simulation or a model is however more tedious that the methods with the remote API.</span></p>
<p><br/>控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用<br/>程序通過各種方式（例如管道，套接字，串行端口等）與<br/>CoppeliaSim 插件或 CoppeliaSim 腳本進行通信。選擇編程語言（可<br/>以是任何一種語言）和靈活性是兩個主要優點。同樣，控制代碼也<br/>可以在機器人或其他電腦上運行。但是，與使用遠程 API 的方法相<br/>比，這種控制仿真或模型的方法更加乏味。</p>
<p><br/><span style="color: #ff0000;">There are 8 scene files related to this tutorial: </span><br/><span style="color: #ff0000;">scenes/controlTypeExamples/controlledViaScript : one robot is controlled via a non-threaded child script, the other is controlled via a threaded child script. scenes/controlTypeExamples/controlledViaPlugin : the robot is controlled via a plugin. scenes/controlTypeExamples/controlledViaB0RemoteApi : the robot is controlled via the B0-based remote API. scenes/controlTypeExamples/controlledViaLegacyRemoteApi : the robot is controlled via the legacy remote API. scenes/controlTypeExamples/controlledViaB0 : the robot is controlled via the BlueZero interface. scenes/controlTypeExamples/con trolledViaRos : the robot is controlled via the ROS interface. scenes/controlTypeExamples/controlledViaRos2 : the robot is controlled via the ROS2 interface. scenes/controlTypeExamples/controlledViaTcp : the robot is controlled via LuaSocket and TCP.</span></p>
<p>有 8 個與本教程相關的場景文件： scenes / controlTypeExamples /受<br/>控 ViaScript：一個機器人是通過非線程子腳本控制的，另一個是通過<br/>線程子腳本控制的。 scenes / controlTypeExamples /受控ViaPlugin：機器人是通過插件控制的。 scenes / controlTypeExamples / controlViaB0RemoteApi：通過基於 B0 的遠程API 來控制機器人。 scenes / controlTypeExamples /受控<br/>ViaLegacyRemoteApi：通過舊版遠程 API 控制機器人。 scenes / <br/>controlTypeExamples / controlViaB0：通過 BlueZero 界面控制機器<br/>人。 scenes / controlTypeExamples /受控 ViaRos：通過 ROS 接口控<br/>制機器人。 scenes / controlTypeExamples / controlViaRos2：通過<br/>ROS2 接口控制機器人。 scenes / controlTypeExamples /受控<br/>ViaTcp：通過 LuaSocket 和 TCP 控制機器人。</p>
<p><img alt="" height="549" src="/images/g.PNG" width="714"/></p>
<p><span style="color: #ff0000;">In all 8 cases, child scripts are used, mainly to make the link with the outside world (e.g. launch the correct client application, and pass the correct object handles to it). There are two other ways one can control a robot, a simulation, or the simulator itself: by using customization scripts, or add-ons. They are however not recommended for control and should be rather used to handle functionality while simulation is not running. </span><br/><span style="color: #ff0000;">As an example, the child script linked to the robot in scene controlledViaB0RemoteApi.ttt has following main task: </span></p>
<p><br/>在所有 8 種情況下，都使用子腳本，主要是為了與外界建立鏈接<br/>（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給<br/>它）。有兩種其他方法可以控制機器人，模擬或模擬器本身：使用自<br/>定義腳本或附加組件。但是，不建議將它們用於控制，而應在不運<br/>行模擬時將其用於處理功能。例如，鏈接到場景控制的<br/>ViaB0RemoteApi.ttt 中的機器人的子腳本具有以下主要任務：</p>
<p><br/> <span style="color: #ff0000;">Launch the controller application (bubbleRobClient_b0RemoteApi) with some object handles as arguments. The server functionality of the B0-based remote API is provided by object b0RemoteApiServer . </span><br/><span style="color: #ff0000;">As another example, the child script linked to the robot in scene controlledViaRos.ttt has following main tasks: </span><br/><span style="color: #ff0000;">Check if the ROS Interface for CoppeliaSim was loaded Launch the controller application (rosBubbleRob) with some topic names or object handles as arguments</span> <br/> <br/>使用某些對象作為參數啟動控制器應用程序<br/>（bubbleRobClient_b0RemoteApi）。基於對象 B0 的遠程 API 的服<br/>務器功能由對象 b0RemoteApiServer 提供。作為另一個示例，鏈接<br/>到場景控制的 ViaRos.ttt 中的機器人的子腳本具有以下主要任務：<br/>檢查是否已加載 CoppeliaSim 的 ROS 接口使用某些主題名稱或對象<br/>作為參數啟動控制器應用程序（rosBubbleRob） <br/> <br/><span style="color: #ff0000;">Yet, as another example, the child script linked to the robot in scene controlledViaTcp.ttt has following main tasks: </span><br/><span style="color: #ff0000;"> Search for a free socket connection port </span><br/><span style="color: #ff0000;"> Launch the controller application (bubbleRobServer) with the chosen connection port as argument Locally connect to the controller application At each simulation pass, send the sensor values to the controller, and read the desired motor values from the controller At each simulation pass, apply the desired motor values to the robot's joints </span><br/><span style="color: #ff0000;">Run the simulations, and copy-and-paste the robot: you will see that the duplicated robots will directly be operational, since their attached child scripts are in charge of launching new instances of their respective external applications, or calling the appropriate plugin functions. </span></p>
<p><br/>然而，作為另一個示例，鏈接到場景控制的 ViaTcp.ttt 中的機器人的<br/>子腳本具有以下主要任務：搜索空閒的套接字連接端口使用所選的<br/>連接端口作為參數啟動控制器應用程序（bubbleRobServer）本地連<br/>接到控制器應用程序在每次仿真過程中，將傳感器值發送到控制<br/>器，並從控制器讀取所需的電機值在每次模擬過程中，將所需的電<br/>機值應用於機器人的關節運行模擬，然後復制並粘貼機器人：您將<br/>看到重複的機器人將直接運行，因為它們附加的子腳本負責啟動各<br/>自外部應用程序的新實例或調用適當的插件功能。</p><h2>BubbleRob</h2>
<p><span style="color: #0000ff;">由40723222提供</span></p>
<p><span style="color: #ff0000;">BubbleRob tutorial </span><br/> <br/><span style="color: #ff0000;">This tutorial will try to introduce quite many CoppeliaSim functionalities while designing the simple mobile robot BubbleRob. The CoppeliaSim scene file related to this tutorial is located in CoppeliaSim's installation folder's tutorials/BubbleRob folder. Following figure illustrates the simulation scene that we will design:</span><span style="color: #0000ff;"> <br/> <br/><span style="color: #000000;">本教程將設計簡單的移動機器人 BubbleRob 並嘗試介紹很多 CoppeliaSim 功能。 與本教程相關的 CoppeliaSim 場景文件位於 CoppeliaSim 的安裝文件夾的 tutorials / BubbleRob 文件夾中。下圖說明了我們將設計的仿真場景：</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><img alt="" height="464" src="/images/1.png" width="738"/></span></span></p>
<p><span style="color: #ff0000;">Since this tutorial will fly over many different aspects, make sure to also have a look at the other tutorials, mainly the tutorial about building a simulation model. First of all, freshly start CoppeliaSim. The simulator displays a default scene. We will start with the body of BubbleRob.</span></p>
<p>由於本教程將跨越許多不同的方面，因此請確保也看看其他教程，主要是有關構建仿真模型的教程。首先，重新啟動CoppeliaSim。模擬器顯示默認場景。我們將從BubbleRob的主體開始。</p>
<p><span style="color: #ff0000;">We add a primitive sphere of diameter 0.2 to the scene with [Menu bar --&gt; Add --&gt; Primitive shape --&gt; Sphere]. We adjust the X-size item to 0.2, then click OK. The created sphere will appear in the visibility layer 1 by default, and be dynamic and respondable (since we kept the item Create dynamic and respondable shape enabled). This means that BubbleRob's body will be falling and able to react to collisions with other respondable shapes (i.e. simulated by the physics engine). We can see this is the shape dynamics properties: items Body is respondable and Body is dynamic are enabled. We start the simulation (via the toolbar button, or by pressing &lt;control-space&gt; in the scene window), and copy-and-paste the created sphere (with [Menu bar --&gt; Edit --&gt; Copy selected objects] then [Menu bar --&gt; Edit -&gt; Paste buffer], or with &lt;control-c&gt; then &lt;control-v&gt;): the two spheres will react to collision and roll away. We stop the simulation: the duplicated sphere will automatically be removed. This default behaviour can be modified in the simulation dialog.</span></p>
<p>我們使用[Menu bar --&gt; Add --&gt; Primitive shape --&gt; Sphere]將直徑為0.2的基本球體添加到場景中。我們將X尺寸項目調整為0.2，然後單擊“確定”。默認情況下，創建的球體將顯示在可見性層1中，並且因該是動態且可響應的（因為我們已啟用“Create dynamic and responsive shapes”）。這意味著BubbleRob的身體會掉落並且能夠對與其他可響應形狀的碰撞做出反應（即由物理引擎模擬）。我們可以看到這是“Shape dynamics”屬性：啟用了“The body can respond”和“Body is dynamic”項目。我們開始模擬（通過工具欄按鈕，或在場景窗口中按&lt;control-space&gt;），然後復制並貼上創建的球體（使用[Menu bar --&gt; Edit --&gt; Copy selected objects]，然後[Menu bar --&gt; Edit -&gt; Paste buffer]，或者先按&lt;control-c&gt;，再按&lt;control-v&gt;）：這兩個球將對碰撞做出反應並滾動。我們停止模擬：重複的球體將自動刪除。可以在模擬對話框中修改此默認行為。</p>
<p><span style="color: #ff0000;">We also want the BubbleRob's body to by usable by the other calculation modules (e.g. the minimum distance calculation module). For that reason, we enable Collidable, Measurable, Renderable and Detectable in the object common properties for that shape, if not already enabled. If we wanted, we could now also change the visual appearance of our sphere in the shape properties.</span></p>
<p>我們還希望BubbleRob的主體可以被其他計算模塊（例如最小距離計算模塊）使用。因此，如果尚未啟用，則在該形狀的對象公共屬性中啟用“Collidable”，“Measurable”，“Renderable”和“Detectable”。如果需要，我們現在還可以在形狀屬性中更改球體的視覺外觀。</p>
<p><span style="color: #ff0000;">Now we open the position dialog on the translation tab, select the sphere representing BubbleRob's body, and enter 0.02 for Along Z. We make sure that the Relative to-item is set to World. Then we click Translate selection. This translates all selected objects by 2 cm along the absolute Z-axis, and effectively lifted our sphere a little bit. In the scene hierarchy, we double-click the sphere's name, so that we can edit its name. We enter bubbleRob and press enter.</span></p>
<p>現在，我們在“平移translation”選項上打開“位置position”對話框，選擇表示BubbleRob身體的球體，並為“沿Z”輸入0.02。確保將“相對於”項設置為“世界World”。然後我們點擊Translate選擇。這會將所有選定對象沿絕對Z軸平移2 cm，並有效地將我們的球體抬高了一點。在場景層次結構中，我們雙擊球體的名稱，以便我們可以編輯其名稱。我們輸入bubbleRob，然後按Enter。</p>
<p><span style="color: #ff0000;">Next we will add a proximity sensor so that BubbleRob knows when it is approaching obstacles: we select [Menu bar --&gt; Add --&gt; Proximity sensor --&gt; Cone type]. In the orientation dialog on the orientation tab, we enter 90 for Around Y and for Around Z, then click Rotate selection. In the position dialog, on the position tab, we enter 0.1 for X-coord. and 0.12 for Z-coord. The proximity sensor is now correctly positioned relative to BubbleRob's body. We double-click the proximity sensor's icon in the scene hierarchy to open its properties dialog. We click Show volume parameter to open the proximity sensor volume dialog. We adjust items Offset to 0.005, Angle to 30 and Range to 0.15. Then, in the proximity sensor properties, we click Show detection parameters. This opens the proximity sensor detection parameter dialog. We uncheck item Don't allow detections if distance smaller than then close that dialog again. In the scene hierarchy, we double-click the proximity sensor's name, so that we can edit its name. We enter bubbleRob_sensingNose and press enter.</span></p>
<p>接下來，我們將添加一個距離傳感器，以便BubbleRob知道它何時接近障礙物：我們選擇[Menu bar --&gt; Add --&gt; Proximity sensor --&gt; Cone type]。在“方向orientation”選項上的“方向orientation”對話框中，我們為“周圍的Y”和“周圍的Z”輸入90，然後單擊“旋轉選擇Rotate selection”。在位置對話框的“位置position”選項上，為X坐標輸入0.1。 Z坐標為0.12。現在，接近傳感器已相對於BubbleRob的身體正確定位。我們在場景層次中雙擊接近傳感器的圖標以打開其屬性對話框。我們單擊顯示體積參數以打開接近傳感器體積對話框。我們將偏移量調整為0.005，角度調整為30，範圍調整為0.15。然後，在距離傳感器屬性中，單擊“顯示檢測參數Show detection parameters”。這將打開距離傳感器去檢測參數對話框。如果距離小於則取消選中“不允許檢測Don't allow detections”項，然後再次關閉該對話框。在場景層次結構中，我們雙擊距離傳感器的名稱，以便我們可以編輯其名稱。我們輸入bubbleRob_sensingNose並enter。</p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><span style="color: #ff0000;">We select bubbleRob_sensingNose, then control-select bubbleRob, then click [Menu bar --&gt; Edit --&gt; Make last selected object parent]. This attaches the sensor to the body of the robot. We could also have dragged bubbleRob_sensingNose onto bubbleRob in the scene hierarchy. This is what we now have:</span><br/> <br/> 我們選擇bubbleRob_sensingNose，然後按住Control鍵選擇bubbleRob，然後單擊[Menu bar --&gt; Edit --&gt;將上一個選定的對象設為parent]。這會將傳感器連接到機器人的身體。我們還可以將bubbleRob_sensingNose拖動到場景層次中的bubbleRob上。這就是我們現在擁有的：</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><img alt="" height="523" src="/images/2.png" width="692"/></span></span></p>
<p>[Proximity sensor attached to bubbleRob's body]</p>
<p><span style="color: #ff0000;">Next we will take care of BubbleRob's wheels. We create a new scene with [Menu bar --&gt; File --&gt; New scene]. It is often very convenient to work across several scenes, in order to visualize and work only on specific elements. We add a pure primitive cylinder with dimensions (0.08,0.08,0.02). As for the body of BubbleRob, we enable Collidable, Measurable, Renderable and Detectable in the object common properties for that cylinder, if not already enabled. Then we set the cylinder's absolute position to (0.05,0.1,0.04) and its absolute orientation to (-90,0,0). We change the name to bubbleRob_leftWheel. We copy and paste the wheel, and set the absolute Y coordinate of the copy to -0.1. We rename the copy to bubbleRob_rightWheel. We select the two wheels, copy them, then switch back to scene 1, then paste the wheels.</span></p>
<p>接下來，我們將設定BubbleRob的車輪。我們使用[Menu bar --&gt; File --&gt; New scene]創建一個新場景。跨多個場景工作通常非常方便，以便可視化並僅對特定元素進行工作。我們添加一個尺寸為（0.08,0.08,0.02）的圓柱體。對於BubbleRob的主體，如果尚未啟用，則在該圓柱的對象通用屬性中啟用Collidable，Measurable，Renderable和Detectable。然後，將圓柱的絕對位置設置為（0.05,0.1,0.04），並將其絕對方向設置為（-90,0,0）。我們將名稱更改為bubbleRob_leftWheel。我們複製並粘貼滾輪，然後將復制的絕對Y坐標設置為-0.1。我們將物件名稱重新命名為bubbleRob_rightWheel。我們選擇兩個輪子，複製它們，然後切換回場景1，然後貼上輪子。</p>
<p><span style="color: #ff0000;">We now need to add joints (or motors) for the wheels. We click [Menu bar --&gt; Add --&gt; Joint --&gt; Revolute] to add a revolute joint to the scene. Most of the time, when adding a new object to the scene, the object will appear at the origin of the world. We Keep the joint selected, then control-select bubbleRob_leftWheel. In the position dialog, on the position tab, we click the Apply to selection button: this positioned the joint at the center of the left wheel. Then, in the orientation dialog, on the orientation tab, we do the same: this oriented the joint in the same way as the left wheel. We rename the joint to bubbleRob_leftMotor. We now double-click the joint's icon in the scene hierarchy to open the joint properties dialog. Then we click Show dynamic parameters to open the joint dynamics properties dialog. We enable the motor, and check item Lock motor when target velocity is zero. We now repeat the same procedure for the right motor and rename it to bubbleRob_rightMotor. Now we attach the left wheel to the left motor, the right wheel to the right motor, then attach the two motors to bubbleRob. This is what we have:</span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;">現在，我們需要為車輪添加動力（或電動機）。我們單擊[Menu bar --&gt; Add --&gt; Joint --&gt; Revolute]將旋轉關節添加到場景。在大多數情況下，將新對象添加到場景時，該對象將出現在世界的起始處。我們保持動力件處於選中狀態，然後控制選擇bubbleRob_leftWheel。在位置對話框的“位置position”選項上，我們單擊“Apply”選擇按鈕：這將動力定位在左輪的中心。然後，在“方向”對話框中的“方向”選項卡上，執行相同的操作：這將關節與左輪定向的方向相同。我們將關節重命名為bubbleRob_leftMotor。現在，我們在場景層次中雙擊關節的圖標以打開關節屬性對話框。然後，單擊“顯示動態參數”以打開關節動力學屬性對話框。我們啟用電動機，然後選中目標速度為零時鎖定電動機。現在，我們對右馬達重複相同的過程，並將其重命名為bubbleRob_rightMotor。現在，我們將左輪連接到左馬達，將右輪連接到右馬達，然後將兩個馬達連接到bubbleRob。這就是我們所擁有的：</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><img alt="" height="536" src="/images/3.png" width="724"/></span></span></p>
<p><span style="color: #ff0000;">[Proximity sensor, motors and wheels]</span></p>
<p><span style="color: #ff0000;">We run the simulation and notice that the robot is falling backwards. We are still missing a third contact point to the floor. We now add a small slider (or caster). In a new scene we and add a pure primitive sphere with diameter 0.05 and make the sphere Collidable, Measurable, Renderable and Detectable (if not already enabled), then rename it to bubbleRob_slider. We set the Material to noFrictionMaterial in the shape dynamics properties. To rigidly link the slider with the rest of the robot, we add a force sensor object with [Menu bar --&gt; Add --&gt; Force sensor]. We rename it to bubbleRob_connection and shift it up by 0.05. We attach the slider to the force sensor, then copy both objects, switch back to scene 1 and paste them. We then shift the force sensor by -0.07 along the absolute X-axis, then attach it to the robot body. If we run the simulation now, we can notice that the slider is slightly moving in relation to the robot body: this is because both objects (i.e. bubbleRob_slider and bubbleRob) are colliding with each other. To avoid strange effects during dynamics simulation, we have to inform CoppeliaSim that both objects do not mutually collide, and we do this in following way: in the shape dynamics properties, for bubbleRob_slider we set the local respondable mask to 00001111, and for bubbleRob, we set the local respondable mask to 11110000. If we run the simulation again, we can notice that both objects do not interfere anymore. This is what we now have:</span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;">我們運行模擬，並注意到機器人向後倒下。我們仍然缺少與地板的第三個接觸點。現在，我們添加一個小的滑塊（或腳輪）。在一個新場景中，我們添加一個直徑為0.05的球體，並使該球體可碰撞，可測量，可渲染和可檢測（如果尚未啟用），然後將其重命名為bubbleRob_slider。我們在形狀動力學屬性中將Material設置為noFrictionMaterial。為了將滑塊與機器人的其餘部分牢固地鏈接在一起，我們使用[菜單欄-&gt;添加-&gt;力傳感器]添加了力傳感器對象。我們將其重命名為bubbleRob_connection並將其上移0.05。我們將滑塊連接到力傳感器，然後復制兩個對象，切換回場景1並貼上它們。然後，我們將力傳感器沿絕對X軸移動-0.07，然後將其安裝到機器人主體上。如果現在運行仿真，我們會注意到滑塊相對於機器人主體略微移動：這是因為兩個對象（即bubbleRob_slider和bubbleRob）彼此碰撞。為了避免在動力學模擬過程中產生奇怪的影響，我們必須通知CoppeliaSim兩個對像不會相互碰撞，我們可以通過以下方式進行此操作：在形狀動力學屬性中，對於bubbleRob_slider，我們將本地可響應模版設置為00001111，對於bubbleRob，我們將本地可響應掩碼設置為11110000。如果再次運行機器人，我們會注意到兩個對像不再相互干擾。這就是我們現在擁有的：</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><img alt="" height="538" src="/images/4.png" width="729"/></span></span></p>
<p><span style="color: #ff0000;">[Proximity sensor, motors, wheels and slider]</span></p>
<p><span style="color: #ff0000;">We run the simulation again and notice that BubbleRob slightly moves, even with locked motor. We also try to run the simulation with different physics engines: the result will be different. Stability of dynamic simulations is tightly linked to masses and inertias of the involved non-static shapes. For an explanation of this effect, make sure to carefully read this and that sections. We now try to correct for that undesired effect. We select the two wheels and the slider, and in the shape dynamics dialog we click three times M=M*2 (for selection). The effect is that all selected shapes will have their masses multiplied by 8. We do the same with the inertias of the 3 selected shapes, then run the simulation again: stability has improved. In the joint dynamics dialog, we set the Target velocity to 50 for both motors. We run the simulation: BubbleRob now moves forward and eventually falls off the floor. We reset the Target velocity item to zero for both motors.</span></p>
<p>我們再次運行機器人，發現即使在電機鎖定的情況下，BubbleRob也會輕微移動。我們還嘗試使用不同的物理引擎運行機器人：結果將有所不同。動態仿真的穩定性與所涉及的非靜態形狀的質量和慣性緊密相關。有關此效果的說明，請務必仔細閱讀本節和該節。現在，我們嘗試糾正這種不良影響。我們選擇兩個輪子和滑塊，然後在“動力學”對話框中單擊3次M = M * 2（用於選擇）。效果是所有選定形狀的質量都將乘以8。我們對3個選定形狀的慣性進行相同的操作，然後再次運行仿真：穩定性得到了改善。在關節動力學對話框中，我們將兩個電機的目標速度都設置為50。我們運行模擬：BubbleRob現在向前移動並最終掉落在地板上。我們將兩個電機的目標速度項都重置為零。</p>
<p><span style="color: #ff0000;">The object bubbleRob is at the base of all objects that will later form the BubbleRob model. We will define the model a little bit later. In the mean time, we want to define a collection of objects that represent BubbleRob. For that we define a collection object. We click [Menu bar --&gt; Tools --&gt; Collections] to open the collection dialog. Alternatively we can also open the dialog by clicking the appropriate toolbar button:</span></p>
<p>對象bubbleRob是所有對象的基礎，所有對象隨後將形成BubbleRob模型。我們將在稍後定義模型。同時，我們要定義代表BubbleRob的對象的集合。為此，我們定義了一個收集對象。我們單擊[Menu bar --&gt; Tools --&gt; Collections]以打開集合對話框。或者，我們也可以通過單擊相應的工具欄按鈕來打開對話框：</p>
<p><img alt="" height="76" src="/images/5.png" width="110"/></p>
<p><span style="color: #ff0000;">In the collection dialog, we click Add new collection. A new collection object appears in the list just below. For now the newly added collection is still empty (not defined). While the new collection item is selected in the list, select bubbleRob in the scene hierarchy, and then click Add in the collection dialog. Our collection is now defined as containing all objects of the hierarchy tree starting at the bubbleRob object (the collection's composition is displayed in the Composing elements and attributes section). To edit the collection name, we double-click it, and rename it to bubbleRob_collection. We close the collection dialog.</span></p>
<p>在集合對話框中，單擊添加新集合。一個新的集合對像出現在下面的列表中。目前，新添加的集合仍為空（未定義）。在列表中選擇新的收藏項時，在場景層次中選擇bubbleRob，然後在收藏對話框中單擊“添加”。現在，我們的集合被定義為包含層次結構樹的所有對象（從bubbleRob對像開始）（集合的組成顯示在“組成元素和屬性”部分中）。要編輯集合名稱，請雙擊它，然後將其重命名為bubbleRob_collection。我們關閉收集對話框。</p>
<p><span style="color: #ff0000;">At this stage we want to be able to track the minimum distance between BubbleRob and any other object. For that, we open the distance dialog with [Menu bar --&gt; Tools --&gt; Calculation module properties]. Alternatively we can also open the calculation module properties dialog with the appropriate toolbar button:</span></p>
<p>在此階段，我們希望能夠跟踪BubbleRob與任何其他對象之間的最小距離。為此，我們使用[Menu bar --&gt; Tools --&gt; Calculation module properties]打開距離對話框。或者，我們也可以使用相應的工具欄按鈕打開計算模塊屬性對話框：</p>
<p><img alt="" height="110" src="/images/6.png" width="177"/></p>
<p><span style="color: #ff0000;">In the distance dialog, we click Add new distance object and select a distance pair: [collection] bubbleRob_collection - all other measurable objects in the scene. This just added a distance object that will measure the smallest distance between collection bubbleRob_collection (i.e. any measurable object in that collection) and any other measurable object in the scene. We rename the distance object to bubbleRob_distance with a double-click in its name. We close the distance dialog. When we now run the simulation, we won't see any difference, since the distance object will try to measure (and display) the smallest distance segment between BubbleRob and any other measurable object in the scene. The problem is that at this stage there is no other measurable object in the scene (the shape defining the floor has its measurable property turned off by default). At a later stage in this tutorial, we will add obstacles to our scene.</span></p>
<p>在距離對話框中，單擊“添加新距離對象”並選擇一個距離對：[collection] bubbleRob_collection-場景中所有其他可測量對象。這只是添加了一個距離對象，該距離對象將測量集合bubbleRob_collection（即該集合中的任何可測量對象）與場景中任何其他可測量對象之間的最小距離。我們通過雙擊其名稱將距離對象重命名為bubbleRob_distance。我們關閉距離對話框。現在，當我們運行模擬時，我們不會看到任何區別，因為距離對象將嘗試測量（並顯示）BubbleRob與場景中任何其他可測量對象之間的最小距離段。問題在於，在此階段，場景中沒有其他可測量的對象（定義地板的形狀默認情況下已禁用其可測量的屬性）。在本教程的後續階段，我們將為場景添加障礙。</p>
<p><span style="color: #ff0000;">Next we are going to add a graph object to BubbleRob in order to display above smallest distance, but also BubbleRob's trajectory over time. We click [Menu bar --&gt; Add --&gt; Graph] and rename it to bubbleRob_graph. We attach the graph to bubbleRob, and set the graph's absolute coordinates to (0,0,0.005). Now we open the graph properties dialog by double-clicking its icon in the scene hierarchy. We uncheck Display XYZ-planes, then click Add new data stream to record and select Object: absolute x-position for the Data stream type, and bubbleRob_graph for the Object / item to record. An item has appeared in the Data stream recording list. That item is a data stream of bubbleRob_graph's absolute x-coordinate (i.e. the bubbleRobGraph's object absolute x position will be recorded). Now we also want to record the y and z positions: we add those data streams in a similar way as above. We now have 3 data streams that represent BubbleRob's x-, y- and z-trajectories. We are going to add one more data stream so that we are able to track the minimum distance between our robot and its environment: we click Add new data stream to record and select Distance: segment length for the Data stream type, and bubbleRob_distance for the Object / item to record. In the Data stream recording list, we now rename Data to bubbleRob_x_pos, Data0 to bubbleRob_y_pos, Data1 to bubbleRob_z_pos, and Data2 to bubbleRob_obstacle_dist.</span></p>
<p>接下來，我們將向BubbleRob添加一個圖形對象，以顯示最小距離以上的距離，同時還顯示BubbleRob隨時間的軌跡。我們單擊[Menu bar --&gt; Add --&gt; Graph]，並將其重命名為bubbleRob_graph。我們將圖形附加到bubbleRob，並將圖形的絕對坐標設置為（0,0,0.005）。現在，通過在場景層次結構中雙擊其圖標來打開圖形屬性對話框。我們取消選中“顯示XYZ平面”，然後單擊“添加新數據流以進行記錄”，然後選擇“對象：數據流類型的絕對x位置”，並選擇“ bubbleRob_graph”作為要記錄的對象/項目。數據流記錄列表中出現了一個項目。該項目是bubbleRob_graph的絕對x坐標的數據流（即，將記錄bubbleRobGraph的對象的絕對x位置）。現在，我們還想記錄y和z位置：我們以與上述類似的方式添加這些數據。現在，我們有3個數據，分別表示BubbleRob的x，y和z軌跡。我們將再添加一個數據流，以便能夠跟踪機器人與其環境之間的最小距離：單擊添加新數據流以進行記錄，然後選擇“距離：數據流類型的段長度”和“氣泡Rob_distance”作為要記錄的對象/項目。在數據流記錄列表中，我們現在將Data重命名為bubbleRob_x_pos，將Data0重命名為bubbleRob_y_pos，將Data1重命名為bubbleRob_z_pos，將Data2重命名為bubbleRob_obstacle_dist。</p>
<p><span style="color: #ff0000;">We select bubbleRob_x_pos in the Data Stream recording list and in the Time graph properties section, uncheck Visible. We do the same for bubbleRob_y_pos and bubbleRob_z_pos. By doing so, only the bubbleRob_obstacle_dist data stream will be visible in a time graph. Following is what we should have:</span></p>
<p>我們在“數據流”記錄列表中和“時間圖屬性”部分中選擇bubbleRob_x_pos，取消選中“可見”。我們對bubbleRob_y_pos和bubbleRob_z_pos都執行相同的操作。這樣，在時間圖中只能看到bubbleRob_obstacle_dist數據流。以下是我們應該擁有的：</p>
<p><img alt="" height="663" src="/images/7.png" width="561"/></p>
<p><span style="color: #ff0000;">[Graph properties]</span></p>
<p><span style="color: #ff0000;">Next we will set-up a 3D curve that displays BubbleRob's trajectory: we click Edit 3D curves to open the XY graph and 3D curve dialog, then click Add new curve. In the dialog that pops open, we select bubbleRob_x_pos for the X-value item, bubbleRob_y_pos for the Y-value item and bubbleRob_z_pos for the Z-value item. We rename the newly added curve from Curve to bubbleRob_path. Finally, we check the Relative to world item and set Curve width to 4:</span></p>
<p>接下來，我們將建立一個顯示BubbleRob軌蹟的3D曲線：單擊“編輯3D曲線”以打開XY圖形和3D曲線對話框，然後單擊“添加新曲線”。在彈出的對話框中，我們為X值項目選擇bubbleRob_x_pos，為Y值項目選擇bubbleRob_y_pos，為Z值項目選擇bubbleRob_z_pos。我們將新添加的曲線從Curve重命名為bubbleRob_path。最後，我們檢查“相對於世界”項目並將“曲線寬度”設置為4：</p>
<p><img alt="" height="383" src="/images/8.png" width="583"/></p>
<p>[<span style="color: #ff0000;">3D curve properties]</span></p>
<p><span style="color: #ff0000;">We close all dialogs related to graphs. Now we set one motor target velocity to 50, run the simulation, and will see BubbleRob's trajectory displayed in the scene. We then stop the simulation and reset the motor target velocity to zero.</span></p>
<p>我們關閉與圖有關的所有對話框。現在我們將一個電機目標速度設置為50，運行模擬，然後將看到BubbleRob的軌跡顯示在場景中。然後，我們停止仿真並將電動機目標速度重置為零。</p>
<p><span style="color: #ff0000;">We add a pure primitive cylinder with following dimensions: (0.1, 0.1, 0.2). We want this cylinder to be static (i.e. not influenced by gravity or collisions) but still exerting some collision responses on non-static respondable shapes. For this, we disable Body is dynamic in the shape dynamics properties. We also want our cylinder to be Collidable, Measurable, Renderable and Detectable. We do this in the object common properties. Now, while the cylinder is still selected, we click the object translation toolbar button:</span></p>
<p>我們添加具有以下尺寸的純原始圓柱體：（0.1，0.1，0.2）。我們希望此圓柱體是靜態的（即不受重力或碰撞的影響），但仍會對非靜態的可響應形狀施加一些碰撞響應。為此，我們在形狀動力學屬性中禁用“主體是動態的”。我們還希望圓柱體是可碰撞的，可測量的，可渲染的和可檢測的。我們在對象的公共屬性中執行此操作。現在，在仍選擇圓柱體的情況下，我們單擊對象平移工具欄按鈕：</p>
<p><img alt="" height="44" src="/images/9.png" width="331"/></p>
<p><span style="color: #ff0000;">Now we can drag any point in the scene: the cylinder will follow the movement while always being constrained to keep the same Z-coordinate. We copy and paste the cylinder a few times, and move them to positions around BubbleRob (it is most convenient to perform that while looking at the scene from the top). During object shifting, holding down the shift key allows to perform smaller shift steps. Holding down the ctrl key allows to move in an orthogonal direction to the regular direction(s). When done, select the camera pan toolbar button again:</span></p>
<p>現在我們可以拖動場景中的任何點：圓柱體將跟隨運動，同時始終受約束以保持相同的Z坐標。我們複製並粘貼圓柱幾次，然後將它們移動到BubbleRob周圍的位置（從頂部查看場景時執行該操作最方便）。在對象移動期間，按住Shift鍵可以執行較小的移動步驟。按住ctrl鍵可以在與常規方向正交的方向上移動。完成後，再次選擇相機平移工具欄按鈕：</p>
<p><img alt="" height="40" src="data:image/png;base64,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" width="172"/></p>
<p><span style="color: #ff0000;">We set a target velocity of 50 for the left motor and run the simulation: the graph view now displays the distance to the closest obstacle and the distance segment is visible in the scene too. We stop the simulation and reset the target velocity to zero.</span></p>
<p>我們將左馬達的目標速度設置為50並運行模擬：現在，圖形視圖顯示了到最近障礙物的距離，並且該距離段在場景中也可見。我們停止模擬並將目標速度重置為零。</p>
<p><span style="color: #ff0000;">We now need to finish BubbleRob as a model definition. We select the model base (i.e. object bubbleRob) then check items Object is model base and Object/model can transfer or accept DNA in the object common properties: there is now a stippled bounding box that encompasses all objects in the model hierarchy. We select the two joints, the proximity sensor and the graph, then enable item Don't show as inside model selection and click Apply to selection, in the same dialog: the model bounding box now ignores the two joints and the proximity sensor. Still in the same dialog, we disable camera visibility layer 2, and enable camera visibility layer 10 for the two joints and the force sensor: this effectively hides the two joints and the force sensor, since layers 9-16 are disabled by default. At any time we can modify the visibility layers for the whole scene. To finish the model definition, we select the vision sensor, the two wheels, the slider, and the graph, then enable item Select base of model instead: if we now try to select an object in our model in the scene, the whole model will be selected instead, which is a convenient way to handle and manipulate the whole model as a single object. Additionally, this protects the model against inadvertant modification. Individual objects in the model can still be selected in the scene by click-selecting them with control-shift, or normally selecting them in the scene hierarchy. We finally collapse the model tree in the scene hierarchy. This is what we have:</span></p>
<p>現在，我們需要完成BubbleRob作為模型定義。我們選擇模型基礎（即對象bubbleRob），然後選中``對像是模型基礎''，然後選擇``對象/模型可以轉移或接受對象共同屬性中的DNA''：現在有一個點畫的邊界框包含模型層次結構中的所有對象。我們選擇兩個關節，即接近傳感器和圖形，然後啟用項目“不顯示為內部模型選擇”，然後在同一對話框中單擊“應用於選擇”：模型邊界框現在將忽略兩個關節和接近傳感器。仍在同一對話框中，我們禁用攝像機可見性層2，並為兩個關節和力傳感器啟用攝像機可見性層10：這有效地隱藏了兩個關節和力傳感器，因為默認情況下禁用第9-16層。我們可以隨時修改整個場景的可見性層。要完成模型定義，我們選擇視覺傳感器，兩個輪子，滑塊和圖形，然後啟用“選擇模型基礎”選項：如果現在嘗試在場景中選擇模型中的對象，則整個模型而是選擇，這是一種將單個模型處理和操縱整個模型的便捷方法。此外，這可以防止模型受到意外修改。仍然可以通過在按住Shift的同時單擊選擇對像或在場景層次結構中正常選擇它們，來在場景中選擇模型中的單個對象。最後，我們將模型樹折疊到場景層次中。這就是我們所擁有的：</p>
<p><img alt="" height="526" src="/images/11.png" width="752"/></p>
<p><span style="color: #ff0000;">[BubbleRob model definition]</span></p>
<p><span style="color: #ff0000;">Next we will add a vision sensor, at the same position and orientation as BubbleRob's proximity sensor. We open the model hierarchy again, then click [Menu bar --&gt; Add --&gt; Vision sensor --&gt; Perspective type], then attach the vision sensor to the proximity sensor, and set the local position and orientation of the vision sensor to (0,0,0). We also make sure the vision sensor is not not visible, not part of the model bounding box, and that if clicked, the model will be selected instead. In order to customize the vision sensor, we open its properties dialog. We set the Far clipping plane item to 1, and the Resolution x and Resolution y items to 256 and 256. We add a floating view to the scene, and over the newly added floating view, right-click [Popup menu --&gt; View --&gt; Associate view with selected vision sensor] (we make sure the vision sensor is selected during that process).</span></p>
<p>接下來，我們將在與BubbleRob接近傳感器相同的位置和方向上添加視覺傳感器。我們再次打開模型層次結構，然後單擊[Menu bar --&gt; Add --&gt; Vision sensor --&gt; Perspective type]，然後將視覺傳感器連接到接近傳感器，並將視覺傳感器的本地位置和方向設置為（0,0,0）。我們還確保視覺傳感器不可見，不是模型邊界框的一部分，並且如果單擊該模型，則會選擇模型。為了自定義視覺傳感器，我們打開其屬性對話框。將“遠裁剪平面”項設置為1，將“分辨率x”和“分辨率y”項設置為256和256。向場景中添加一個浮動視圖，並在新添加的浮動視圖上，右鍵單擊[Popup menu --&gt; View --&gt; Associate view with selected vision sensor]（我們確保在該過程中選擇了視覺傳感器）。</p>
<p><span style="color: #ff0000;">We attach a non-threaded child script to the vision sensor by clicking [Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]. We double-click the little icon that appeared next to the vision sensor in the scene hierarchy: this opens the child script that we just added. We copy and paste following code into the script editor, then close it:</span></p>
<p>通過單擊[Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]，將非線程子腳本附加到視覺傳感器。我們雙擊場景層次結構中視覺傳感器旁邊出現的小圖標：這將打開我們剛剛添加的子腳本。我們將以下代碼複製並粘貼到腳本編輯器中，然後將其關閉：</p>
<p><img alt="" height="146" src="/images/12.png" width="1033"/></p>
<p><span style="color: #ff0000;">To be able to see the vision sensor's image, we start the simulation, then stop it again.</span></p>
<p>為了能夠看到視覺傳感器的圖像，我們開始模擬，然後再次停止。</p>
<p><span style="color: #ff0000;">The last thing that we need for our scene is a small child script that will control BubbleRob's behavior. We select bubbleRob and click [Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]. We double-click the script icon that appeared next to bubbleRob's name in the scene hierarchy and copy and paste following code into the script editor, then close it:</span></p>
<p>我們場景所需的最後一件事是一個小的子腳本，它將控制BubbleRob的行為。我們選擇bubbleRob並單擊[Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]。我們雙擊場景層次結構中bubbleRob名稱旁邊顯示的腳本圖標，然後將以下代碼複製並粘貼到腳本編輯器中，然後將其關閉：</p>
<p><img alt="" height="681" src="/images/13.png" width="1036"/></p>
<p><span style="color: #ff0000;">We run the simulation. BubbleRob now moves forward while trying to avoid obstacles (in a very basic fashion). While the simulation is still running, change BubbleRob's velocity, and copy/paste it a few times. Also try to scale a few of them while the simulation is still running. Be aware that the minimum distance calculation functionality might be heavily slowing down the simulation, depending on the environment. You can turn that functionality on and off in the distance dialog, by checking / unchecking the Enable all distance calculations item.</span></p>
<p>我們運行模擬。 BubbleRob現在在嘗試避開障礙物的同時向前移動（以非常基本的方式）。在模擬仍在運行時，更改BubbleRob的速度，然後將其複制/粘貼幾次。在模擬仍在運行時，也嘗試擴展其中的一些。請注意，根據環境的不同，最小距離計算功能可能會嚴重降低仿真速度。您可以通過選中/取消選中“啟用所有距離計算”項來在“距離”對話框中打開和關閉該功能。</p>
<p><span style="color: #ff0000;">Using a script to control a robot or model is only one way of doing. CoppeliaSim offers many different ways (also combined), have a look at the external controller tutorial.</span></p>
<p>使用腳本控制機器人或模型只是一種方法。 CoppeliaSim提供了許多不同的方法（也可以結合使用），請參閱外部控制器教程。</p>
<h2>Line following</h2>
<p><span style="color: #0000ff;">由40723243提供</span></p>
<p><strong><span style="color: #ff0000;">Line following BubbleRob tutorial</span> </strong><br/><strong>使 BubbleRob 沿著固定軌跡的教程</strong></p>
<p><br/><span style="color: #ff0000;">In this tutorial we aim at extending the functionality of BubbleRob to let him/her follow a line on the ground. Make sure you have fully read and understood the first BubbleRob tutorial. This tutorial is courtesy of Eric Rohmer.</span> <br/>在本教程中，我們要擴展 BubbleRob 的功能，以使他遵循地面上的軌跡。確保您已經<br/>閱讀並理解了第一個 BubbleRob 教程。本教程由 Eric Rohmer 提供。 <br/><span style="color: #ff0000;">Load the scene of the first BubbleRob tutorial located in CoppeliaSim's installation folder, in tutorials/BubbleRob. The scene file related to this tutorial is located in tutorials/LineFollowingBubbleRob. Following figure illustrates the simulation scene that we will design:</span></p>
<p><br/>在 CoppeliaSim 的安裝文件夾中的 tutorials / BubbleRob 中加載第一個 BubbleRob 教程的場景。與本教程相關的場景文件位於 tutorials / LineFollowing BubbleRob 中。下圖說明了我們將設計的仿真場景：</p>
<p><img alt="" height="474" src="/images/a.PNG" width="732"/></p>
<p><span style="color: #ff0000;">We first create the first of 3 vision sensors that we will attach to the bubbleRob object. Select [Menu bar --&gt; Add --&gt; Vision sensor --&gt; Orthographic type]. Edit its properties, by double-clicking on the newly created vision sensor icon in the scene hierarchy, and change the parameters to reflect following dialog:</span></p>
<p><br/>我們首先創建三個視覺傳感器中的第一個，並將其附加到 bubbleRob 物件中。選擇<br/>[Menu bar -&gt; Add -&gt; Vision sensor -&gt; Orthographic type]。通過雙擊場景中新創建的視覺傳感器圖標來編輯其屬性，並更改參數以反映以下對話框：</p>
<p><img alt="" height="584" src="/images/b.PNG" width="385"/></p>
<p><span style="color: #ff0000;">The vision sensor has to be facing the ground, so select it, and in the orientation dialog, on the orientation tab, set [180;0;0] for the Alpha-Beta-Gamma items.</span> <br/> <br/>視覺傳感器必須面向地面，因此選擇它，然後在“orientation”對話框中的<br/>“orientation”選項上，將“ Alpha-Beta-Gamma”項設置為[180; 0; 0]。 <br/> <br/><span style="color: #ff0000;">We have several possibilities to read a vision sensor. Since our vision sensor has just one pixel and operates in an easy way, we will simply query the average intensity value of the image read by our vision sensor. For more complex cases, we could have set-up a vision callback function. Now copy and paste the vision sensor twice, and adjust its names to leftSensor, middleSensor and rightSensor. Make bubbleRob their parent (i.e. attach them to the bubbleRob object). Your sensors should now look like this in the scene hierarchy:</span> <br/> <br/>我們有幾種可能可以讀取視覺傳感器的方式。由於我們的視覺傳感器只有一個像素，<br/>並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更<br/>複雜的情況，我們可以設置視覺回調函數。現在，複製並貼上視覺傳感器兩次，並將<br/>其名稱調整為 leftSensor，middleSensor 和 rightSensor。將 bubbleRob 設置為其父級<br/>（即，將其附加到 bubbleRob 對象）。現在，您的傳感器在場景層次中應如下所示：</p>
<p><img alt="" height="255" src="/images/c.PNG" width="248"/></p>
<p><span style="color: #ff0000;">Let's position the sensors correctly. For that use the position dialog, on the position tab, and set following absolute coordinates:</span></p>
<p><br/>讓我們正確放置傳感器。為此，使用位置對話框，在位置選項上，並設置以下絕對坐標： <br/>左傳感器：[0.2; 0.042; 0.018]</p>
<p>中間傳感器：[0.2; 0; 0.018]</p>
<p>右傳感器：[0.2; -0.042; 0.018] </p>
<p><img alt="" height="109" src="/images/d.PNG" width="412"/><br/> <br/><span style="color: #ff0000;">Now let's modify the environment. We can remove a few cylinders in front of BubbleRob. Next, we will build the path that the robot will try to follow. It is probaby better to switch to a top view from now on: select page 4 via the page selector toolbar button. Then click [Menu bar --&gt; Add --&gt; Path --&gt; Circle type]. Enable the object movement with the mouse. You have two possibilities to adjust the shape of the path:</span> <br/> <br/>現在我們可以修改環境。我們可以移去 BubbleRob 前面的幾個圓柱體。接下來，我們<br/>將構建機器人將嘗試使機器人遵循的路徑。從現在開始最好切換到頂視圖：通過頁面<br/>選擇器工具欄按鈕選擇頁面 4。然後單擊[菜單欄-&gt;添加-&gt;路徑-&gt;圓圈類型]。使用鼠標<br/>啟用對象移動。您可以通過兩種方式調整路徑的形狀： <br/> <br/>1. 選擇路徑（並且只有路徑）後，按住 Ctrl 並單擊其控制點之一。然後可以將它們<br/>拖動到正確的位置。 <br/>2. 選擇路徑後，進入路徑編輯模式。在那裡，您可以自由地調整各個路徑控制點。 <br/> <br/><span style="color: #ff0000;">Once you are satisfied with the geometry of the path (you can always modify it at a later stage), select it, and uncheck Show orientation of points, Show path line and Show current position on path in the path properties. Then click Show path shaping dialog. This opens the path shaping dialog. Click Path shaping enabled, set the type to horizontal segment, and Scaling factor to 4.0. Finally adjust the color to black. There is a last important adjustment we have to make to the path: currently, the z-position of the path coincides with the zposition of the floor. The consequence is that sometimes we see the path, sometimes the floor (this effect is known as z-fighting in the openGl jargon). This not only affects what we see, but also what the vision sensors see. In order to avoid problems linked to z-fighting, just move the position of the path object up by 0.5 mm.</span> <br/> <br/>一旦對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改），請選擇它，<br/>然後在路徑屬性中取消“Show orientation of points 顯示點的方向”，“Show path line<br/>顯示路徑線”和“Show current position on path in the path properties 顯示路徑上的當<br/>前位置”。然後單擊顯示路徑外型的對話框。這將打開路徑外型對話框。單擊啟用路<br/>徑外型，將類型設置為水平線段，並將縮放因子設置為 4.0。最後將顏色調整為黑<br/>色。我們必須對路徑進行最後一個重要的調整：當前，路徑的 z 位置與地板的 z 位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在 openGl 中被稱為“z-fighting”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與 z-fighting 有關的問題，只需將路徑對象的位置向上移動 0.5 毫米</p>
<p><span style="color: #ff0000;">The last step is to adjust the controller of BubbleRob, so that it will also follow the black path. Open the child script attached to bubbleRob, and replace it with following code</span>: <br/> <br/>最後一步是調整 BubbleRob 的控制器，使其也將遵循黑色路徑。打開附加到<br/>bubbleRob 的子腳本，並將其替換為以下代碼：</p>
<pre class="lightRedBox">function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end

function sysCall_init()
    -- This is executed exactly once, the first time this script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)
    leftMotor=sim.getObjectHandle("leftMotor")
    rightMotor=sim.getObjectHandle("rightMotor")
    noseSensor=sim.getObjectHandle("sensingNose")
    minMaxSpeed={50*math.pi/180,300*math.pi/180}
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
    floorSensorHandles={-1,-1,-1}
    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")
    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")
    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")
    -- Create the custom UI:
        xml = '&lt;ui title="'..sim.getObjectName(bubbleRobBase)..' speed" closeable="false" resizeable="false" activate="false"&gt;'..[[
        &lt;hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/&gt;
        &lt;label text="" style="* {margin-left: 300px;}"/&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.reate(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end

function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor)
    if (result&gt;0) then backUntilTime=sim.getSimulationTime()+4 end

    -- read the line detection sensors:
    sensorReading={false,false,false}
    for i=1,3,1 do
        result,data=sim.readVisionSensor(floorSensorHandles[i])
        if (result&gt;=0) then
            sensorReading[i]=(data[11]&lt;0.3) -- data[11] is the average of intensity of the image
        end
        print(sensorReading[i])
    end

    -- compute left and right velocities to follow the detected line:
    rightV=speed
    leftV=speed
    if sensorReading[1] then
        leftV=0.03*speed
    end
    if sensorReading[3] then
        rightV=0.03*speed
    end
    if sensorReading[1] and sensorReading[3] then
        backUntilTime=sim.getSimulationTime()+2
    end

    if (backUntilTime&lt;sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,leftV)
        sim.setJointTargetVelocity(rightMotor,rightV)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        sim.setJointTargetVelocity(leftMotor,-speed/2)
        sim.setJointTargetVelocity(rightMotor,-speed/8)
    end
end

function sysCall_cleanup()
	simUI.destroy(ui)
end</pre>
<p><span style="color: #ff0000;">You can easily debug your line following vision sensors: select one, then in the scene view select [Right-click --&gt; Add --&gt; Floating view], then in the newly added floating view select [Right click --&gt; View --&gt; Associate view with selected vision sensor].</span> <br/> <br/>您可以輕鬆地調試以下視覺傳感器的線：選擇一個，然後在場景視圖中選擇[右鍵-&gt;添加-&gt;浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵-&gt;視圖- -&gt;將視圖與選定的視覺傳感器關聯]。 <br/> <br/><span style="color: #ff0000;">Finally, remove the auxiliary items that were added in the first BubbleRob tutorial: remove the image processing vision sensor, its associated floating view, the floating view representing the obstacle clearance. Remove also the distance calculation object via the distance dialog. That's it!</span> <br/> <br/>最後，刪除在第一個 BubbleRob 教程中添加的輔助項：刪除圖像處理視覺傳感器，其關聯的浮動視圖，該浮動視圖表示障礙物的清除。通過距離對話框也刪除距離計算對象。</p><h2>simulation</h2>
<p><span style="color: #0000ff;">由40723221提供</span></p>
<p><span style="color: #ff0000;"><strong>Simulation</strong></span></p>
<p><strong>模擬</strong></p>
<p><span style="color: #ff0000;">A simulation in CoppeliaSim can be started, paused and stopped with [Menu bar --&gt; Simulation --&gt; Start/Pause/Stop simulation] or through the related toolbar buttons:</span></p>
<p>可以使用<span>[</span>菜單欄<span>-&gt;</span>模擬<span>-&gt;</span>開始<span>/</span>暫停<span>/</span>停止模擬<span>]</span>或通過相關的工具欄按鈕來啟動，暫停和停止<span>CoppeliaSim</span>中的模擬：</p>
<p><img alt="" height="37" src="/images/0.png" width="124"/></p>
<p><span style="color: #ff0000;">[Simulation start/pause/stop toolbar buttons]</span></p>
<p><span>[</span>模擬開始<span>/</span>暫停<span>/</span>停止工具欄按鈕<span>]</span></p>
<p><span style="color: #ff0000;">Internally, the simulator will use additional intermediate states in order to correctly inform scripts or programs about what will happen next. Following state diagram illustrates the simulator's internal states:</span></p>
<p>在模擬內，模擬器將使用其他中間狀態，以正確告知腳本或程序接下來將發生的情況。以下狀態圖說明了模擬器的內部狀態：</p>
<p><span style="color: #ff0000;">[Simulation state diagram]</span></p>
<p><span>[</span>模擬狀態圖<span>]</span></p>
<p><span><img alt="" height="489" src="https://s40723221.github.io/cd2020/images/simulation%20state%20diagram.png" width="640"/></span></p>
<p><span style="color: #ff0000;">Scripts and programs should alwaysreact according to the current system call function and possibly the simulation state in order to behave correctly. It is good practice to divide each control code into at least 4 system call functions (e.g. for non-threaded child scripts):</span></p>
<p>腳本和程序應始終根據當前系統調用功能以及可能的模擬狀態進行反應，以便正確運行。優良作法是將每個控制代碼至少分為<span>4</span>個系統調用函數（例如，用於非線程子腳本）：</p>
<p><span style="color: #ff0000;">1.Initialization function: sysCall_init: the function is called only when the script is initialized.</span></p>
<p><span style="color: #ff0000;">2.Actuation function: sysCall_actuation: the function is called when actuation should happen.</span></p>
<p><span style="color: #ff0000;">3.Sensing function: sysCall_sensing: this function is called when sensing should happen.</span></p>
<p><span style="color: #ff0000;">4.Clean-up function: sysCall_cleanup: the function is called just before the script is de-initialized (e.g. at simulation end, or when the script is destroyed)</span></p>
<p><span>1.Initialization</span><span>函數：</span><span>sysCall_init</span><span>：僅在腳本初始化時調用該函數。</span></p>
<p><span>2.actuation</span>函數：<span>sysCall_actuation</span>：應在發生<span>actuation</span>時調用該函數。</p>
<p><span>3.Sensing</span>函數：<span>sysCall_sensing</span>：當應該進行檢測時調用此函數。</p>
<p><span>4.Clean-up</span>函數：<span>sysCall_cleanup</span>：該函數在腳本未初始化之前被調用（例如在模擬結束時或腳本被銷毀時）</p>
<p><span style="color: #ff0000;">For examples on how to arrange a typical script, refer to the main script, the child scripts and customization scripts pages.</span></p>
<p>有關如何安排典型腳本的示例，請參閱主腳本，子腳本和自定義腳本頁面。</p>
<p><span style="color: #ff0000;">The simulator operates by advancing the simulation time at constant time steps. Following figure illustrates the main simulation loop</span></p>
<p>模擬器通過以恆定的時間步長推進模擬時間來進行操作。下圖說明了主要的模擬循環</p>
<p><span style="color: #ff0000;">Simulation loop</span></p>
<p><span><img alt="" height="196" src="https://s40723221.github.io/cd2020/images/simulation%20loop.png" width="450"/></span></p>
<p><span style="color: #ff0000;">[Main simulation loop]</span></p>
<p><span>[</span>主要模擬路徑參考圖<span>]</span></p>
<p><span style="color: #ff0000;">Real-time simulation is supported by trying to keep the simulation time synchronized with the real time:</span></p>
<p>通過嘗試使模擬時間與實時保持同步來支持實時模擬：</p>
<p><img alt="" height="293" src="https://s40723221.github.io/cd2020/images/main%20simulation%20loop.png" width="450"/></p>
<p><span style="color: #ff0000;">[Real-time simulation loop]</span></p>
<p><span>[</span>加入真實時間後的模擬參考圖<span>]</span></p>
<p><span style="color: #ff0000;">Following represents a very simplified main client application (messaging, plugin handling and other details have been omitted for clarity purpose):</span></p>
<p>以下是一個非常簡單的主客戶端應用程序（為清晰起見，已省略了消息，插件處理和其他詳細信息）：</p>
<p>void initializationCallback<br/>{<br/>    // do some initialization here</p>
<p>}</p>
<p> </p>
<p>void loopCallback<br/>{<br/>    if ( (simGetSimulationState()&amp;sim_simulation_advancing)!=0 )<br/>    {<br/>        if ( (simGetRealTimeSimulation()!=1)||(simIsRealTimeSimulationStepNeeded()==1) )<br/>        {<br/>            if ((simHandleMainScript()&amp;sim_script_main_script_not_called)==0)<br/>                simAdvanceSimulationByOneStep();<br/>        }<br/>    }<br/>}</p>
<p> </p>
<p>void deinitializationCallback<br/>{<br/>    // do some clean-up here</p>
<p>}</p>
<p><span style="color: #ff0000;">Depending on the simulation complexity, performance of the computer and simulation settings, real-time simulation might not always be possible.</span></p>
<p>取決於模擬的複雜性，電腦的性能和模擬設置，實時模擬的時候並不總是完美的。</p>
<p><span style="color: #ff0000;">In non real-time simulations, the simulation speed (i.e. the perceived speed) is mainly dependent on two factors: the simulation time step and the number of simulation passes for one rendering pass (see the simulation dialog for more details). In the case of a real-time simulation, the simulation speed mainly depends on the real-time multiplication coefficient, but also to a certain degree of the simulation time step (a too small simulation time step might not be compatible with the real-time character of a simulation because of the limited calculation power of the computer). During simulation, the simulation speed can be adjusted with following toolbar buttons</span></p>
<p>在非實時模擬中，模擬速度（即感知速度）主要取決於兩個因素：模擬時間步長和一個渲染通道的模擬通道數量（有關更多詳細信息，請參見模擬對話框）。在實時模擬的情況下，模擬速度主要取決於實時乘法係數，而且在一定程度上取決於模擬時間步長（太小的模擬時間步長可能與實時時間不兼容）。由於計算機的計算能力有限，因此無法進行模擬。在模擬過程中，可以通過以下工具欄按鈕來調節模擬速度</p>
<p><span style="color: #ff0000;">Simulation speed</span></p>
<p><span><img alt="" height="37" src="https://s40723221.github.io/cd2020/images/simulation%20speed.png" width="81"/></span></p>
<p><span style="color: #ff0000;">[Simulation speed adjustment toolbar buttons]</span></p>
<p><span style="color: #ff0000;">The simulation speed is adjusted in a way so that the initial simulation time step is never increased (because this might have as consequence the breaking of a mechanism for example). Following two figures illustrate the simulation speed adjustment mechanisms</span></p>
<p>以某種方式調整模擬速度，以使初始模擬時間的步長永遠不會增加（這可能因此而導致機制中斷）。下兩個圖說明了模擬速度調節機制</p>
<p><img alt="" height="173" src="https://s40723221.github.io/cd2020/images/i1.png" width="600"/></p>
<p><span style="color: #ff0000;">[Simulation speed adjustment mechanism for non real-time simulations]</span><br/>[非實時模擬的模擬速度調整機制]</p>
<p><img alt="" height="180" src="https://s40723221.github.io/cd2020/images/i2.png" width="600"/></p>
<p><span style="color: #ff0000;">[Simulation speed adjustment mechanism for real-time simulations]</span></p>
<p>[實時模擬與調整機制]</p>
<p><span style="color: #ff0000;">By default, each simulation cycle is composed by following sequential operations:</span></p>
<p><span style="color: #ff0000;">1.Executing the main script</span></p>
<p><span style="color: #ff0000;">2.Rendering the scen</span></p>
<p>默認情況下，每個模擬週期由以下順序操作組成：</p>
<p><span>1.</span>執行主腳本</p>
<p><span>2.</span>渲染場景</p>
<p><span style="color: #ff0000;">Threaded rendering</span></p>
<p><span style="color: #ff0000;">The rendering operation will always increase the simulation cycle duration, thus also slowing down simulation speed. The number of main script executions per scene rendering can be defined (see further up), but this is not enough in some situations, because rendering will still slow down every xth simulation cycle (which can be handicapping with real-time requirements). For those situations, a threaded rendering mode can be activated via the user settings, or via the following toolbar button:</span><br/><span style="color: #ff0000;">When the threaded rendering mode is activated, a simulation cycle will only consist in execution of the main script, thus simulations will run at maximum speed. Rendering will happen via a different thread, and not slow down the simulation task. The drawbacks have however to be considered. When threaded rendering is activated, then:</span></p>
<p><img alt="" height="34" src="https://s40723221.github.io/cd2020/images/fire.png" width="35"/><br/><span style="color: #ff0000;"> [Threaded rendering toolbar button]</span></p>
<p><span style="color: #ff0000;">Rendering will happen asynchronously to the simulation loop, and visual glitches might appear</span></p>
<p><span style="color: #ff0000;">The video recorder will not operate at constant speed (some frames might get skipped)</span></p>
<p><span style="color: #ff0000;">The stability of the application might be reduced</span></p>
<p><span style="color: #ff0000;">Some operations (e.g. erasing an object, etc.) require to wait for the rendering thread to finish work, before being able to execute, and vice-versa. In those situations, cycles could take more time than in the sequential rendering mode</span></p>
<p>交互渲染</p>
<p>渲染操作將始終增加模擬週期的持續時間，從而也降低了模擬速度。可以定義每個場景渲染的主腳本執行次數（請參閱後面的內容），但這在某些情況下還不夠，因為渲染仍然會減慢每個第<span>x</span>個模擬週期的時間（這可能會限制實時性）。在這種情況下，可以通過用戶設置或以下工具欄按鈕激活線程渲染模式：</p>
<p><span> [</span>線程渲染工具欄按鈕<span>]</span></p>
<p>激活線程渲染模式後，模擬週期將僅包含在執行主腳本中，因此模擬將以最大速度運行。渲染將通過不同的線程進行，並且不會減慢模擬任務的速度。然而，必須考慮缺點。激活線程渲染後，：</p>
<p>渲染將與模擬循環不會同步進行，並且可能會出現視覺上的瑕疵</p>
<p>錄影機將無法以恆定速度運行（可能會跳過某些幀數）</p>
<p>應用程序的穩定性可能會降低</p>
<p>某些操作（例如去除物件等）需要等待渲染得線程完成工作才能執行，反之亦然。在那些情況下，循環可能比有順序的渲染模式花費更多的時間。</p>
<p><span style="color: #ff0000;"><strong>Simulation dialog</strong></span></p>
<p><strong>模擬控制視窗</strong></p>
<p><span style="color: #ff0000;">The simulation dialog can be accessed with [Menu bar --&gt; Simulation --&gt; Simulation settings] or by clicking following toolbar button:</span></p>
<p>可以通過<span>[</span>菜單欄<span>-&gt;</span>模擬<span>-&gt;</span>模擬設置<span>]</span>或單擊以下工具欄按鈕來訪問模擬對話框：</p>
<p><img alt="" height="37" src="https://s40723221.github.io/cd2020/images/tool1.png" width="38"/></p>
<p><span style="color: #ff0000;">[Simulation toolbar button]</span></p>
<p><span>[</span>模擬工具欄按鈕<span>]</span></p>
<p><span><img alt="" height="353" src="https://s40723221.github.io/cd2020/images/toolbar.png" width="396"/></span></p>
<p><span style="color: #ff0000;">[Simulation settings dialog]</span></p>
<p>模擬設定視窗</p>
<p><span style="color: #ff0000;">Time step: the simulation time step. Each time the main script was executed, the simulation time is incremented by the simulation time step. Using large time steps results in fast but inaccurate/unstable simulations. Small time steps on the other hand will (generally) lead to more precise simulations, but will take more time. It is highly recommended to keep a default time step.</span></p>
<p><span style="color: #ff0000;">Simulation passes per frame (ppf): the number of simulation passes for one rendering pass. A value of 10 would mean that the main script is executed 10 times (10 simulation steps) before the screen is refreshed. If you have a slow graphic card, you can choose to display only one frame out of two for instance.</span></p>
<p><span style="color: #ff0000;">Pause when simulation time higher than: allows specifying a simulation time at which the simulation will be paused (e.g. to be able to analyze some results at a specific simulation time).</span></p>
<p><span><span style="color: #ff0000;">Pause on script</span> error: if enabled, then a simulation will be paused when a script error occurs.</span></p>
<p>時間步長：模擬時間步長。每次執行主腳本時，模擬時間都會增加模擬時間的步長。使用較大的時間步長會導致快速但不准確<span>/</span>不穩定的模擬。另一方面，較小的時間步長（通常）會有更精確的模擬，但是會花費更多時間。強烈建議保留默認的時間步長。</p>
<p>每幀模擬次數（<span>ppf</span>）：一個渲染遍的模擬次數。其值為<span>10</span>表示刷新屏幕之前，主腳本已執行<span>10</span>次（<span>10</span>個模擬步驟）。如果您的顯示卡較慢，則可以選擇僅顯示兩幅中的一幅。</p>
<p>當模擬時間高於以下時間時則會暫停：允許指定暫停模擬的模擬時間（例如，能夠在特定模擬時間分析某些結果）。</p>
<p>腳本錯誤暫停：如果啟用，則在腳本錯誤發生時暫停模擬。</p>
<p><span style="color: #ff0000;">Full screen at simulation start: if enabled, then simulation starts in full screen mode. Be aware that in full screen mode, dialogs and messages won't appear or won't be visible, and only the left mouse button will be active. For that reason that mode is only recommended once a scene is properly configured and final. Full screen mode can be left with the esc-key, and toggled via the boolean parameter sim_booparam_fullscreen during simulation. Unler Linux and MacOS the full-screen mode might only partially be supported, and switching back to normal mode might fail on certain systems.</span></p>
<p>模擬開始時全屏：如果啟用，則模擬以全屏模式開始。請注意，在全屏模式下，設置視窗和消息將不會出現或不可見，只有鼠標左鍵處於活動狀態時才會出現。因此，僅在正確配置場景並最終確定場景後才建議使用該模式。可以使用<span>esc</span>鍵保留全屏模式，並在模擬過程中通過布爾參數<span>sim_booparam_fullscreen</span>進行切換。<span><span> </span>Unler Linux</span>和<span>MacOS</span>可能僅部分支持全屏模式，並且在某些系統上切換回普通模式可能會失敗。</p>
<p><span style="color: #ff0000;">Real-time simulation, multiplication factor: if selected, then the simulation time will try to follow the real-time. A multiplication factor of X would try to run a simulation X times faster than real-time.</span></p>
<p>實際時間的模擬，倍增係數：如果選擇，則模擬時間將嘗試跟隨實際時間。<span><span> </span>X</span>的乘數將使模擬運行比實時快<span>X</span>倍。</p>
<p><span style="color: #ff0000;">Try catching up when behind: during real-time simulation, it can happen that the simulation time is not able to follow the real-time (e.g. because of some momentarily heavy calculations). In that case, if this check-box is selected, then the simulation time will try catching up the lost time (e.g. when the calculation load is again reduced), which results in an apparent speed-up.</span></p>
<p>在落後時嘗試趕上：在實時模擬過程中，模擬時間可能無法實時跟踪（例如，由於某些瞬間繁重的計算）。在這種情況下，如果選中此複選框，則模擬時間將嘗試趕上不足的時間（例如，當計算負載再次減少時），從而明顯加快速度。</p>
<p><span style="color: #ff0000;">Reset scene to initial state: when selected, then all objects will be reset to their initial state: this includes the object local position, local orientation and its parent (as long as the object wasn't modified otherwise (e.g. scaled)), joint and path intrinsic positions, floating view positions and sizes, etc. This means that the next simulation run will execute in a same way as previous one, unless heavy changes were undertaken (shape scaling, object removal, etc.). Some minor settings are ignored by this item.</span></p>
<p>將場景重置為初始狀態：選中後，所有物件都將重置為其初始狀態：包括對象的局部位置，局部方向及其父對象（只要未進行其他修改（例如，縮放），以及路徑的固有位置，浮動視圖的位置和大小等。這意味著除非進行了重大更改（形狀縮放，對象移除等），否則下一次模擬運行將以與上一次相同的方式執行。此項目將忽略一些次要設置。</p>
<p><span style="color: #ff0000;">Remove new objects: when selected, then scene objects added during a simulation run will be removed at the end of the simulation.</span></p>
<p>刪除新對象：選中後，在模擬運行期間添加的場景對象將在模擬結束時被刪除。</p><h1>assignments</h1>
<h2>assignment1</h2>
<p><a href="https://github.com/s40723221/cd2020/blob/master/downloads/Collaborative%20product%20design%20processes%20of%20industrial%20design%20and%20engineering%20design%20in%20consumer%20product%20companies%E7%BF%BB%E8%AD%AF.pdf">Collaborative product design processes of industrial design and engineering design in consumer product companies</a></p>
<p>1. Describe how to do an efficient random grouping for this course or do the roll calling randomly?</p>
<p>2. Describe how to prepare a portable Python programming system for Windows 10 64bit system to allow one the maintain<span> </span><a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a><span> </span>website,<span> </span><a href="https://github.com/getpelican/pelican">Pelican blog</a><span> </span>and<span> </span><a href="https://github.com/hakimel/reveal.js/">Reveal.js</a><span> </span>presentation on<span> </span><a href="https://github.com/">Github</a>?</p>
<p>3. What do you need to know from <a href="http://www.coppeliarobotics.com/helpFiles/index.html">http://www.coppeliarobotics.com/helpFiles/index.html</a> to implement a four-wheeled robot?</p>
<h3>Random grouping</h3>
<p><span lang="en"><span style="color: #3366ff;">資料提供及統整:40723221</span> </span></p>
<p><span lang="en">1.如何從網站中抓取所需之資料(如名單)?</span></p>
<p><span lang="en">2.順利抓取名單後如何運用於程式中並使其能夠正確的讀取?</span></p>
<p><span lang="en">3.如何在上述皆達成後順利達到分組的效果?<br/><br/>我們必須要了解 import 的 request、ast、random 是甚麼模組。</span></p>
<p><span lang="en">(1) Request 為能夠下載網頁的一項 python 中的模組，我們能夠使用 request.get(加入網址)的方式來達到擷取網頁資料的目的。</span></p>
<p><span lang="en"><span>參考連結</span>:<span> </span><a href="https://blog.gtwang.org/programming/python-requests-module-tutorial/">https://blog.gtwang.org/programming/python-requests-module-tutorial/</a><br/>(2) ast 中的 literal_eval 可以將剛剛擷取下來的網頁資料(僅允許為字符串，字<br/>節對象(bytes)，數值，元組，列表，字典，集合，布爾值和 None)才可以進<br/>行轉換。<br/></span></p>
<p><span lang="en"><span>參考連結</span>:<span> </span><a href="https://docs.python.org/zh-cn/3/library/ast.html">https://docs.python.org/zh-cn/3/library/ast.html</a></span></p>
<p><span lang="en">(3) random 中有許多不同的用法，在每周抽點中我們使用的是 shuffle 的用法， 此 用法會將給定的元素隨機打亂，以達到亂數的目的。</span></p>
<p><span lang="en"><span>參考連結</span>:<span> </span><a href="https://ithelp.ithome.com.tw/articles/10207483">https://ithelp.ithome.com.tw/articles/10207483</a></span></p>
<p><span lang="en">最後我們可以經由 for 迴圈對剛剛打亂的元素進行我們所想要的分法已達到 亂數分組中的分組的目的。<br/><br/><span>亂數分組及每周抽點程式比較</span>:亂數分組必須要從 index.html 中去抓取網址， 如在 html 中不存在網址才會從主程式 evenGrouping.dart 中抓取網址，而每 周抽點的程式中則是採用 Request 的方式去產生擷取網站資料的目的，在亂 數分組中可以以 dart 的方式去 run 就會達到分組的目的，也可以使用 scite 進 行 python 指令的運行，這樣也可以對每周抽點進行抽點運行。</span></p>
<h3>Portable system</h3>
<p><span style="color: #3366ff;">資料提供及資料統整:40723221、40723237、 40723249 、40723244 </span></p>
<p><span lang="en">問題:如何對現有的可攜進行更新 python 至 3.8.2 的動作，可攜系統的完整安裝流程，及 python3.8.2 的運行需要做哪一些更動?<br/><br/><span>(1)直接對舊有可攜進行更新<span> </span></span></span><span lang="en"><span>將可攜系統下的 python 3.7.3 系統更新至 python 3.8.2</span><br/></span></p>
<p><span lang="en">1.進入 <a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a><br/>2.往下滑到最底，下載 Windows x86-64 executable installer(上下兩者分別為 Windows x86-64 embeddable zip file 和 Windows x86-64 web-based installer 這兩者是嵌入式64位元python的可執行壓縮檔案和64位元網際端的可執行檔 案)在本次可攜的更新中不會使用到<br/>3.接著開始下載切記不要勾選 pip 選項，接著按下 next<br/>4.先將下載下來的python3.8.2放置桌面，並且將y槽下的data新增加一個py382 的資料夾方便之後可以做測試是否 3.8.2 之 python 可以正常的運行<br/>5.將剛剛下載之 python3.8.2 放置於剛剛創建的 py382 中切記不要將原先的 py373刪除，若之後 py382 的執行產生錯誤才可以使用 py373 做返回原版本的 動作<br/>6.更改執行檔 start_mdecourse.bat 將底下 py373 處更改為自己下在 python3.8.2 所儲存的資料夾名稱<br/></span></p>
<p><span lang="en"><img alt="" height="746" src="https://s40723221.github.io/cd2020/images/LEO%E5%95%8F%E9%A1%8C.PNG" width="1061"/><br/>[start 開啟檔的修改]</span></p>
<p><span lang="en">7.重新啟動剛剛更新的執行檔<br/>8.執行 python get-pip.py<br/>9..執行 python -m pip install flask flask-cors markdown lxml bs4 pelican leo<br/><span style="color: #ff0000;">影片教學網址 :</span><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/ft4s-DvMk_M" width="560"></iframe><br/><br/><span>(2)從頭對創建 python3.8.2 的可攜</span></span></p>
<p><span lang="en">1.往下滑到最底，下載 Windows x86-64 executable installer</span></p>
<p><span lang="en">2.SciTE：到 https://www.scintilla.org/SciTEDownload.html，下載 ” full 64-bit download” 把檔案 ”wscite432” 搬移至 data 目錄底下，在到data下的wscite432 下的 wscite 目錄下執行”scite.exe”，且<span>打開 Options 下的 Global Options File 其中的預設值 code.page=0 修改設定為 code.page=65001，將 load.on.activate=1 前面的井字號拿掉</span></span></p>
<p><span lang="en">3. MSYS2：https://www.msys2.org/ 下載 msys2-x86_64-20190524.exe 並執行</span></p>
<p><span lang="en">4. PortableGit：https://git-scm.com/download/win 下載 64-bit Git for Windows Portable 安裝在 data 目錄下</span></p>
<p><span lang="en">5.安裝pip為以更新的方式更新可攜或者是以從頭開始的方式更新可攜都必須要 安裝指令為 python get-pip.py</span></p>
<p><span lang="en"> 6. 指令為 pip install flask bs4 lxml pelican markdown flask_cors 也必須要安裝這些模組</span></p>
<p><span lang="en">7.</span>home<span>：</span>把舊的 2019fall/data/home 裡面複製 .gitconfig 並貼到新的 home 裡</p>
<p><span lang="en">8.</span>tcc<span>：</span>到 <a href="https://github.com/TinyCC/tinycc">https://github.com/TinyCC/tinycc</a> 接著到命令提示字元裡 git clone <a href="https://github.com/TinyCC/tinycc.git">https://github.com/TinyCC/tinycc.git</a> tcc</p>
<p><span lang="en">9.</span>Jupyterlab<span>：</span><span>到命令提示字元裡使用 pip install jupyterlab==2.0.1 就會自動安裝進去</span></p>
<p><span lang="en">10.</span>Fossil SCM<span>：</span>到 <a href="https://www.fossil-scm.org/home/doc/trunk/www/index.wiki">https://www.fossil-scm.org/home/doc/trunk/www/index.wiki</a> 下載 fossil scm <span>下載完後，解壓縮檔案到 CD2020/data</span></p>
<p><span>11.</span>Flutter<span>：</span>到 <a href="https://github.com/flutter/flutter">https://github.com/flutter/flutter</a> <span>接著到命令提示字元裡 git clone https://github.com/flutter/flutter.git -b stable</span></p>
<p><span>12.</span><span>vscode：</span><span>到 <a href="https://github.com/microsoft/vscode">https://github.com/microsoft/vscode</a> 接著到命令提示字元裡 git clone https://github.com/microsoft/vscode.git  vscode</span></p>
<p><span>13.</span>tmp<span>：</span>git clone 自己的倉儲</p>
<p><span>影片教學網址 :</span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/HuHDDvwnMag" width="560"></iframe></p>
<p><span lang="en"><br/><br/>兩者的比較差異:更新舊有的可攜需要的主要為 python get-pip.py 與下載模 組 pip install flask bs4 lxml pelican markdown flask_cors 並且對 開啟檔 start_mdecourse.bat 進行內容的更動及可，從頭開始執行可攜的更新則 比較麻煩需要下載的模組較多，必須對 SciTE、MSYS2、PortableGit、Tiny C Compiler、Jupyterlab、Fossil SCM 有需要甚至可以將 webots、v-rep 及其他如sharex 等軟體載入可攜系統中。</span></p><h3>four wheel car</h3>
<p><span style="color: #3366ff;">本資料由40723222提供</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm"><strong>BubbleRob tutorial</strong></a><strong>:</strong>在此教程中可以透過我們自行設置的BubbleRob機器人進行初步的模擬，在上學期中我們有實際的以v-rep操作過這個教程，在這個教程中有含括了很多包括如何建造模型(機器人本體、輪子、後方支撐滑塊、障礙物)，並且經由設定好的距離傳感器去感知並且避開我們所設立的障礙物，其中很重要的要點是如何去設計指令使輪胎兩側的傳動器依照我們所想要的方式去做運動，且當距離感測器接近我們所設立的障礙物時，他必須要做出相對應的反應部會使其碰到障礙物，另外還必須要考慮到視覺辨識系統，使機器人在移動時我們能夠觀測到機器人前方之狀況，此教程能夠使我們更加有效率的使用v-rep這套模擬軟體。</p>
<p>影片教學網址:<span><span> </span><a href="https://www.youtube.com/watch?v=CXGJmwHt81g&amp;t=59s">https://www.youtube.com/watch?v=CXGJmwHt81g&amp;t=59s</a></span></p>
<p><span style="color: #3366ff;">本資料由40723243</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm"><strong>Line following BubbleRob tutorial</strong></a><strong>:</strong>在此模擬教程中我們銜接上面的BubbleRob教程，我們想要使其能夠按照我們所規劃的路徑移動，在四輪車的方面這樣的功能能夠使我們有效的規劃四輪車的行走路徑，以達到更好去控制四輪的目的，在無外部控制器或者是想要直接在模擬器的環境中直接模擬可以採用該方法達到比較好的效率。</p>
<p><span style="color: #3366ff;">本資料由40723240提供</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm"><strong>External controller tutorial</strong></a><strong>:</strong>遠端控制器教程中，當我們想要從遠端電腦的方式控制我們在模擬中的物件例如:四輪車或機器人時我們就會需要一項遠程控制的控制器，我們可以參考<a href="https://www.coppeliarobotics.com/helpFiles/en/ros1Tutorial.htm">ROS tutorial</a>及<a href="https://www.coppeliarobotics.com/helpFiles/en/ros2Tutorial.htm">ROS 2 tutorial</a>來達到我們想做控制的想法，<span>ROS</span>主要比較像是對於機器人的中間控制系統，他能夠藉由傳感器來指引機器人該往哪個方向移動，如下圖所示，就是<span>ROS</span>較好的解釋。</p>
<p>ROS:比較像是在負責為機器人的各個元件進行溝通與操作的一個框架，以機器人的行走為例，要讓機器人走路需要控制其底下的馬達、還有一些感測器以進行避開障礙物的功能等等，ROS內就有這種類型的函式可以讓控制馬達的程式得以與接收感測器的程式溝通。</p>
<p><img alt="" height="194" src="https://s40723221.github.io/cd2020/images/ros.png" width="434"/></p>
<p><span style="color: #3366ff;">本資料由40723221提供</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm"><strong>Simulation</strong></a><strong>:</strong>這裡主要是在描述模擬是如何建立的，在模擬中我們雖然比較不會受到的限制很少，但是因為硬體的關係我們必須要適度調整好例如:模擬的速度快慢、非主要物件的加入或移除，我們也可以從這裡看到系統是如何調整速度運行的快慢和機制。</p>
<p><span style="color: #3366ff;">本資料由40723221提供</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm"><strong>Simulation settings dialog</strong></a><strong>:</strong></p>
<p>這篇教程主要在幫助我們理解如何設定模擬時所需要設定的視窗要如何操控，並且講解當我們導入實際的時間運行時，模擬會產生怎樣的變化，但當我們使用加速或減慢時模擬的變化又會怎樣，在一般的情況下模擬的時間步長如果太快會造成模擬的結果及過程不精確甚至會有偵數漏掉的問題，如果太慢雖然會有較精確的結果和過程但會使得模擬時的總時長太久，在某些結構較符雜的模擬之下，模擬在運行到較為複雜的動作或者較難去運算的動作時會使得模擬的時間跟不上實際的時間，這時v-rep內建有寫入能夠補正此bug的方式，他可以藉由進行其他較為簡單的運動模擬時加速已達到與原先時長同步的效果。</p>
<p><span>總結</span>:完成四輪車的模擬必須要有對於模擬軟體的熟悉、馬達的設立、外部控制器的連結、模型的組立、結構的評估(過於複雜的結構可以經由省略內部某些部份零件或者是外觀零件的方式達到簡化)、內部攝像頭的設立、如何以程式(如:python)去所存於模擬中的物件並且對外部控制器做連結，若要進行只單單在模擬軟體中的模擬而不依靠外部控制器去控制作動，則必須要設定在內部模擬器中的感測器(如:距離感射器、視覺感測器等等……)並且布置如線條或者是障礙物的方式去使感測器運行，使物件達到想要的避讓或者是作動，而要達到這些都必須通過程式的設置來完成。</p>
<p><span>ast</span>模組<span>:<a href="https://docs.python.org/zh-cn/3/library/ast.html">https://docs.python.org/zh-cn/3/library/ast.html</a></span></p>
<p><span>Rendom</span>模組<span>:<a href="https://ithelp.ithome.com.tw/articles/10207483">https://ithelp.ithome.com.tw/articles/10207483</a></span></p>
<p><span>Request:<a href="https://blog.gtwang.org/programming/python-requests-module-tutorial/">https://blog.gtwang.org/programming/python-requests-module-tutorial/</a></span></p>
<p><span>mde.tw</span>中分組之程式<span>:<a href="http://mde.tw/cd2020/content/Grouping.html">http://mde.tw/cd2020/content/Grouping.html</a></span></p>
<p>v-rep使用手冊: <span><a href="http://www.coppeliarobotics.com/helpFiles/index.html">http://www.coppeliarobotics.com/helpFiles/index.html</a></span> </p>